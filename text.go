package shirei

import (
	"slices"
	"unicode"
	"unicode/utf8"

	"golang.org/x/text/unicode/bidi"

	g "go.hasen.dev/generic"

	"github.com/cespare/xxhash/v2"
	"github.com/go-text/typesetting/harfbuzz"
	"github.com/go-text/typesetting/language"

	"github.com/dboslee/lru"
)

type TextStyle struct {
	Families []string
	FontAspect

	Color Vec4
	Size  f32
}

type TextAttrs struct {
	TextStyle

	MaxWidth f32
}

func DefaultFontAspect() FontAspect {
	return FontAspect{
		Weight:  WeightNormal,
		Style:   StyleNormal,
		Stretch: StretchNormal,
	}
}

const DefaultTextSize = 14

func DefaultTextStyle() TextStyle {
	return TextStyle{
		Color:      Vec4{0, 0, 0, 1},
		Size:       DefaultTextSize,
		FontAspect: DefaultFontAspect(),
	}
}

func DefaultTextAttrs() TextAttrs {
	return TextAttrs{
		TextStyle: DefaultTextStyle(),
	}
}

func ShapedTextLayout(shaped ShapedText, attrs TextAttrs, selectionFrom int, selectionTo int) {
	// defer profiler.Time("ShapedTextLayout")()

	var blockAttrs Attrs
	blockAttrs.MaxSize[0] = attrs.MaxWidth
	// TODO: allow text attribute to control alignment
	if shaped.BaseDir == RTL {
		blockAttrs.SelfAlign = AlignEnd
	}

	var nextLinePaddingTop float32 // to manage spaces between lines

	Layout(blockAttrs, func() {
		for _, line := range shaped.Lines {
			// expand-across is necessary for the alignment to work
			var lineAttrs Attrs
			lineAttrs.Row = true
			lineAttrs.NoAnimate = true
			lineAttrs.ExpandAcross = true
			lineAttrs.MaxSize[0] = attrs.MaxWidth
			lineAttrs.MinSize[1] = attrs.Size
			lineAttrs.Padding[PAD_TOP] = nextLinePaddingTop
			nextLinePaddingTop = line.Height - attrs.Size

			// TODO: allow text attribute to control alignment
			if shaped.BaseDir == RTL {
				lineAttrs.MainAlign = AlignEnd
			}
			Layout(lineAttrs, func() {
				// pass 1: background highlight
				Layout(Attrs{Floats: true, Row: true, ExpandAcross: true}, func() {
					for _, s := range line.Segments {
						for _, g := range s.Glyphs {
							var bg Attrs
							bg.MinSize[0] = g.XAdvance // FIXME: use width instead of x advance?
							bg.MinSize[1] = attrs.Size
							runeIndex := int(g.Cluster)
							if runeIndex >= selectionFrom && runeIndex < selectionTo {
								bg.Background = Vec4{220, 50, 70, 0.5}
							}
							Element(bg)
						}
					}
				})

				// pass 2: actual glyphs
				for _, s := range line.Segments {
					for _, g := range s.Glyphs {
						var a Attrs
						a.MinSize[0] = g.XAdvance // FIXME: use width instead of x advance?
						a.MinSize[1] = attrs.Size
						a.Background = attrs.Color

						Layout(a, func() {
							current.fontId = g.FontId
							current.glyphId = g.GlyphId
							current.glyphOffset = g.Offset
						})
					}
				}
			})
		}
	})
}

// Generated by ChatGPT (initially)
func SafeTruncateUTF8(s string, limit int) string {
	if len(s) <= limit {
		return s
	}
	cut := limit
	backstop := max(0, limit-4)

	// step back while in continuation bytes (10xxxxxx)
	for cut > backstop && (s[cut]&0xC0) == 0x80 {
		cut--
	}
	return s[:cut]
}

// for now, one line only
func Text(label string, attrs TextAttrs) {
	// For performance reasons, do not accept text larger than 16kb
	// We will add a segmented text view in the future to handle large text blobs
	label = SafeTruncateUTF8(label, 4*1024)

	// defer profiler.Time("Text")()
	shaped := ShapeText(label, attrs)
	ShapedTextLayout(shaped, attrs, 0, 0)
}

type TextLayout struct {
	Segments []GlyphsSegment
}

type GlyphsSegment struct {
	GlyphSegmentProps
	Width  float32
	Height float32
	Glyphs []Glyph
}

type Glyph struct {
	FontId   FontId
	GlyphId  GlyphId
	Cluster  int32
	Offset   Vec2
	XAdvance float32
	Width    float32
	// Scale float32

	// FIXME should this be here?
	Direction Direction
}

var hbfonts = make(map[FontId]*harfbuzz.Font)

func shapeSegment(props GlyphSegmentProps, text []rune, start, length int) (s GlyphsSegment) {
	// defer profiler.Time("shapeSegment")

	s.GlyphSegmentProps = props

	fontId := props.font

	if fontId == 0 {
		// FIXME should we fill in some values??
		return s
	}

	face := GetFace(fontId)

	buf := harfbuzz.NewBuffer()
	buf.AddRunes(text, start, length)
	buf.Props.Script = props.sc
	buf.Props.Direction = harfbuzz.LeftToRight + harfbuzz.Direction(props.Dir)
	buf.Props.Language = "en-EN"

	// this could set language to utf-8 which would *crash* the language parser!!
	// buf.GuessSegmentProperties() // this seems to just set the default locale language; regardless of content!

	font := hbfonts[fontId]
	if font == nil {
		ttf := GetParsedFont(fontId)
		if ttf == nil {
			return s
		}
		font = harfbuzz.NewFont(ttf)
		hbfonts[fontId] = font
		// TODO use lru cache instead of map?
	}

	buf.Shape(font, nil)

	scaleFactor := face.InvUPM * props.size

	s.Height = scaleFactor * (face.Ascender - face.Descender)

	for i := range buf.Info {
		inf := buf.Info[i]
		pos := buf.Pos[i]
		g.Append(&s.Glyphs, Glyph{
			FontId:    fontId,
			GlyphId:   inf.Glyph,
			Cluster:   int32(inf.Cluster),
			Offset:    Vec2{float32(pos.XOffset) * scaleFactor, float32(pos.YOffset) * scaleFactor},
			XAdvance:  float32(pos.XAdvance) * scaleFactor,
			Width:     GlyphWidth(fontId, inf.Glyph) * scaleFactor,
			Direction: props.Dir,
		})
		s.Width += float32(pos.XAdvance) * scaleFactor // TODO is there a better thing? advance is not always the same as width :/
	}

	return s
}

func produceShapedSegments(runes []rune, dirs []Direction, fontIds []FontId, aspect FontAspect, size float32) []GlyphsSegment {
	var allSegments []GlyphsSegment

	var lineNo int

	getSegmentProps := func(i int) GlyphSegmentProps {
		ch := runes[i]
		font, _ := findMatchingFontAndGlyph(ch, fontIds, aspect)
		if ch == '\n' {
			lineNo++
		}
		return GlyphSegmentProps{
			font:    font,
			size:    size,
			sc:      language.LookupScript(ch),
			Dir:     dirs[i],
			isSpace: isSpace(ch),
			lineNo:  lineNo,
		}
	}

	var segment = getSegmentProps(0)
	var start = 0
	for i := range runes {
		segmentNext := getSegmentProps(i)

		// special case!!
		if segmentNext.sc == language.Inherited {
			segmentNext.sc = segment.sc
		}

		if segmentNext != segment {
			var glyphSegment = g.AllocAppend(&allSegments)
			glyphSegment.GlyphSegmentProps = segment
			length := i - start
			allSegments = append(allSegments, shapeSegment(segment, runes, start, length))
			segment = segmentNext
			start = i
		}
	}
	// last segment!
	length := len(runes) - start
	allSegments = append(allSegments, shapeSegment(segment, runes, start, length))

	return allSegments
}

func lineBreakShapedSegments(allSegments []GlyphsSegment, attrs TextAttrs) []ShapedTextLine {

	// break segments into lines
	var lines []ShapedTextLine
	{
		var prevLineNo int // first segment always has line number set to 0
		var maxWidth = attrs.MaxWidth
		var widthAcc float32
		var height float32
		var start int
		for i, segment := range allSegments {
			var widthOverflow = i > start && maxWidth > 0 && segment.Width+widthAcc > maxWidth
			var forceLineBreak = segment.lineNo > prevLineNo
			if widthOverflow || forceLineBreak {
				lines = append(lines, ShapedTextLine{
					Segments: allSegments[start:i],
					Width:    widthAcc,
					Height:   height,
				})
				start = i
				widthAcc = 0
				height = 0
			}
			widthAcc += segment.Width
			height = max(height, segment.Height)
			prevLineNo = segment.lineNo
		}
		lines = append(lines, ShapedTextLine{
			Segments: allSegments[start:],
			Width:    widthAcc,
			Height:   height,
		})
	}

	var baseDir = allSegments[0].Dir
	var reverseDir = baseDir ^ 1 // flips the lower bit, and we only have two values, so

	// reverse continuous reverse runs
	for i := range lines {
		line := &lines[i]

		// if RTL, flip the entire thing first, then flip LTR runs
		// if LTR, just flip RTL runs
		if baseDir == RTL {
			slices.Reverse(line.Segments)
		}

		var dir = baseDir
		var start = 0
		for i := range line.Segments {
			dir1 := line.Segments[i].Dir
			if dir == baseDir && dir1 == reverseDir {
				// start of a new reverse run
				start = i
				dir = dir1
			} else if dir == reverseDir && dir1 == baseDir {
				// end of revers run
				slices.Reverse(line.Segments[start:i])
				start = -1
				dir = dir1
			}
		}
		// last reverse run!
		if dir == reverseDir {
			slices.Reverse(line.Segments[start:])
		}
	}

	return lines
}

type Direction byte

const (
	LTR Direction = iota
	RTL
)

type GlyphSegmentProps struct {
	font    FontId
	size    float32
	sc      language.Script
	Dir     Direction
	isSpace bool
	lineNo  int // hack for line breaks
}

func isSpace(ch rune) bool {
	return unicode.Is(unicode.Zs, ch)
}

type ShapedText struct {
	Runes   []rune
	BaseDir Direction
	Lines   []ShapedTextLine
}

type ShapedTextLine struct {
	Segments []GlyphsSegment
	Width    float32
	Height   float32
}

var shapeCache = lru.New[uint64, ShapedText](lru.WithCapacity(100))

func ShapeText(text string, attrs TextAttrs) ShapedText {
	// defer profiler.Time("ShapeText")()

	fontIds := make([]FontId, 0, len(attrs.Families))
	for _, fontName := range attrs.Families {
		fontIds = append(fontIds, LookupFace(FaceLookupKey{fontName, attrs.FontAspect}))
	}

	var shaped ShapedText
	if len(text) == 0 {
		return ShapedText{}
	}

	// Caching
	var cacheKey uint64
	{
		var hash = xxhash.New()
		HashString(hash, text)
		Hash(hash, &attrs.MaxWidth)
		Hash(hash, &attrs.Color)
		Hash(hash, &attrs.Size)
		Hash(hash, &attrs.FontAspect)
		HashSlice(hash, fontIds)
		cacheKey = hash.Sum64()

		cached, cacheFound := shapeCache.Get(cacheKey)
		if cacheFound {
			return cached
		}
	}

	var runes = []rune(text)
	var dirs = ParagraphBidi(text)
	allSegments := produceShapedSegments(runes, dirs, fontIds, attrs.FontAspect, attrs.Size)
	shaped.Runes = runes
	shaped.BaseDir = allSegments[0].Dir
	shaped.Lines = lineBreakShapedSegments(allSegments, attrs)

	shapeCache.Set(cacheKey, shaped)

	return shaped
}

func findMatchingFontAndGlyph(ch rune, fonts []FontId, aspect FontAspect) (FontId, GlyphId) {
	var fontId FontId
	var glyphId GlyphId
	for _, fid := range fonts {
		gid := LookupGlyph(fid, ch)
		if gid == 0 {
			continue
		} else {
			fontId = fid
			glyphId = gid
			break
		}
	}

	if fontId == 0 || glyphId == 0 {
		return FallbackFontFor(ch, aspect)
	}

	return fontId, glyphId
}

var bidiCache = lru.New[string, []Direction]()

// works with a single line of text, not an article with multiple paragraphs!
func ParagraphBidi(txt string) []Direction {
	out, found := bidiCache.Get(txt)
	if found {
		return out
	}

	out = make([]Direction, utf8.RuneCountInString(txt))

	var paragraph bidi.Paragraph
	paragraph.SetString(txt)
	ordering, err := paragraph.Order()
	if err != nil {
		panic(err)
	}
	for i := range ordering.NumRuns() {
		run := ordering.Run(i)
		start, end := run.Pos() // NOTE: end is inclusive
		dir := Direction(run.Direction())
		for j := start; j <= end; j++ {
			out[j] = dir
		}
	}

	bidiCache.Set(txt, out)

	return out
}
